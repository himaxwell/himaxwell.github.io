Welcome back! Here's the story so far.

In part one, we looked at concerns in Ruby, what they are and how they work. We ended by saying that we wanted to go a bit deeper, understanding not just what concerns are but also how to use them well.

To do that, we took a bit of a detour in part two and discussed a number of clean coding principles. We covered _a lot_ of ground in that post, but the big takeaway was:

> Thinking about the messages that our classes can send and respond to yields high-quality (i.e., inexpensively changeable) designs.

In this post, we are going to dig deeper into this message mindset and come full circle by relating it to how we use concerns in Ruby.

### Messages are Kind of the Point Anyway

Going back to our restaurant example from part two, if we want pizza and a restaurant can respond to the "pizza" message, that's really all we care about, isn't it? What matters isn't the steps used to prepare the pizza so much as getting a response of delicious, as-ordered pizza to our "Pizza please!" message. In other words,

> We mostly care about pizza-like behavior in response to our "Pizza please!" message.

And perhaps this emphasis on behavior seems familiar. You may recall from part one that we discussed this diagram:

[TODO: image here]

Let's go back to our family fun park example from part one. You may recall this diagram:

[TODO: image here]

Here, we are using a `Bookable` concern to share code among several otherwise unrelated classes. By including this concern, these classes can now behave like `Bookable` things...

In other words, we can now treat these classes like `Bookables`...

In other, other words:
- We can now send these classes `Bookable` messages and
- They now know how to respond like `Bookables` should

To put it another way:

```
If a class says that it can respond
to a given set of messages
=
This is a "Behaves like a" contract
=
Which is the very definition of
Polymorphism!
```

To make it even more succinct:

> By including a concern in our class, we are enabling our class to respond to all of the messages that the included concern understands and can respond to.

### Acting Out

At the end of the day, given classes A and B, the only thing that `ClassA` really cares about is whether or not `ClassB` responds to the message that `ClassA` wants to send to `ClassB`. This may bring to mind the famous saying:

> If it walks like a duck and talks like a duck, you can treat it like a duck!

This is a concept known as "Duck Typing":

> A "duck type" defines an interface or role that responds to a given set of messages and is:
>
> - A central location for logic
> - Adoptable by any object that needs to play the role

Does the above definition for "duck type" sound familiar to anyone? Hopefully, your mind is going back to this diagram from before:

[TODO: image here]

Remember earlier when we said that:

> A well-designed concern reaps the benefits of shared **code** while minimizing dependency

Well, here's another way of saying the same thing:

> A well-designed concern reaps the benefits of shared **a shared role** while minimizing dependency

We've been dancing around the issue, but let's just spell it out:

> By including a concern in our class, we are taking on duck type (aka. polymorphic) behavior!

Here's another way to visualize this:

[TODO: image here]

Basically, we have three distinct terms that are all referring to the same concept.

### All Roads Lead to...
Remember earlier when we took a detour? It was to get here, where we can say:

> A ***concern*** allows a ***class*** to play a ***role*** via ***polymorphism***.

Thanks to our detour, the word "role" has (hopefully) a lot more meaning than it did earlier. Ideally, when you think about playing a role you immediately realize that doing so means responding to all of the messages that the role understands. To put it another way:

> A class that includes a concern (takes on a role) can now respond to all of the messages that the concern understands.

In fact, the statement that "you included a concern and now your class can respond to this new set of messages" isn't just a cool observation. Remeber that this is polymorphism that we're talking about. And polymorphism is a contract that your class will behave a certain way.

### So You Want to Include a Concern?
This leads us to probably the number one bad practice or misuse when it comes to concerns. You've probably seen it:

> Developer needs to accomplish a task and thus needs some functionality.
> 
> Developer notices that a concern has a method or methods that have said functionality.
> 
> Developer includes concern in class.
>
> Boom - done, right?

Hopefully, you're shaking your head "no." Because what has this developer just done? More than just add functionality, right? They've actually added polymorphic behavior to this class by giving it the concern's role. The class is now expected to properly respond to every message that the concern (the new role) understands.

But is this what the developer intended to do? No! They just wanted functionality, not for their class to take on an entire role. In this case, the developer knows what a concern is but doesn't understand how to properly use them. Hopefully, now you won't be that developer!

### And They all Lived...
It would be nice if we could end the story here, but if you've been working in software for any length of time and had to work with concerns, then you know that there's more to the story.

To help illustrate the minefield that we're wading through, here is some real-world footage of developers trying to use concerns:

[TODO: image here]

Just kidding. Mostly.

You might've thought that this post would wrap up this series, a nice little trilogy of blog posts that you can revisit with your kids and grandkids for years to come. Not so fast. Like any media conglomerate determined to milk an IP for every cent it's worth, there _will_ be sequels, whether you want them or not!

Just kidding. In all seriousness though, there's more to talk about here and we would be remiss not to.

### Finding the Foot Guns
Let's talk about the foot guns inherent in using concerns. We've actually already unearthed one which we might as well make explicit:

> Footgun #1: Concerns are misused when they are included for their functionality and not because we want our class to play a role.

---

For our next foot gun, recall that earlier when discussing the importance of messages we said that it's a good idea to ask, "Who is responsible for responding to this message?"

Well consider this diagram:

[TODO: image here]

Above, we can see how a message-based view of things pretty quickly uncovers the latent complexity in this architecture. Also recall when we compared the diagram of inheritance to that of a concern and how we said that the relationship/dependency created by using a concern is much less explicit than that created when using inheritance. And that leads us to:

> Footgun #2: Using concerns increases the accidental complexity of an application.

And here, "accidental complexity" is avoidable complexity. Some complexity is inherent to what we're doing and is unavoidable. However, some complexity gets added in due to the choices that we make, and we call this accidental complexity, i.e., the complexity that we should seek to avoid and/or minimize as much as possible. Thus, if using concerns increases the complexity of our application but there's another, less-complex approach that we could use, we would be wise to use it instead.

### It Doesn't End There...
Consider this diagram:

[TODO: image here]

All is well and good until the brand new dev on the team gets assigned a ticket to allow users to be deleted and now suddenly our code looks like this:

[TODO: image here]

To summarize this problem:

[TODO: image here]

> Footgun #3: Only take on roles that make sense for your class to play!

When considering this foot gun, we see that it's a good idea to take a step back and evaluate before using a concern:
- What inherent relationship do documents and folders have? Hopefully, the standard desktop paradigm used by most operating systems makes this one apparent.

But now throw users into the mix. While a user may own files and folders, when it comes to shared functionality between users and files/folders, they don't really align. For example:
- You can open a file or a folder, but what does it mean to "open" a user?
- It makes sense to read the contents of a file or folder, but what does it mean to "read" a user?
- We can delete users, which is usually a permanent operation. However, deleting a file or folder generally means it goes into the trash from which it can often be restored for a period of time.

From a high-level view, there's really no role that it makes sense for files/folders and users to share. We can use a concern to give them `Trashable` functionality, but what we are after is functionality, not a role, which means a concern isn't the correct tool to use here.

### TL;DR
You're probably surprised to read this in a blog post about concerns, but really the TL;DR from my years in the industry is:

> Don't use concerns.

I'm not saying that polymorphism/duck typing is bad, but rather that concerns are an error-prone implementation of these concepts. The main reason for their error-proneness is:

> When using concerns, 100% of the onus is on the individual developer to use them correctly.

Now, one may well argue, "But doesn't this apply to pretty much everything about programming?" Kind of, but I'd argue that concerns are a special case because the real question isn't, "Can this thing be misused", but rather, "How easy or difficult is it to spot misuses?"

Take inheritance for example. Misuses of inheritance are much more obvious due to the inherent hierarchical nature of inheritance. Also, inheritance is a much easier concept to understand that polymorphism. Thus, on the continuum of simple vs. complex and easy vs. difficult to understand, concerns/polymorphism fall in the category of "complex and difficult to understand."

So, seriously….

> Don’t use concerns!

If you have to use them:

> Try something else first!

OK, if you must...

[TODO: image here]

We here at Maxwell have come up with this handy template we have our developers fill out any time they want to use a concerns:

[TODO: image here]

What could possibly go wrong...

[TODO: image here]

Or...perhaps there's a better way. Perhaps there exists something that will allow us to reap some of the same benefits as concerns without the drawbacks.

Spoiler: There is! And this concept will be subject of the final blog post in this series. See you next time!
 
